# 虚拟现实

> 原文链接:[VIRTUAL REALITY](http://www.paul-reed.co.uk/programming.html)

 

# 简介

我对虚拟现实的兴趣来源于这样一个事实：过去通常会花较多的时间去制作3D模型，同时也用一些类似于google cardbord的工具来制作一个虚拟现实的app，这些非常容易。如何保证你使用正确格式的图片正在变成一个更加重要的问题，有些工具包要求你使用一个基于球体的全景图，有一些需要你使用立方体贴图－很明显是基于立方体实现的。我们迫切要做的就是编写程序或者脚本能够转换两种格式的图片。


# 什么是全景图

全景图作为扁平的2D图片是呈现球体的一种最简单的方式，投影将子午线映射到图片中固定间距的垂直直线，将纬度圈映射到图片固定间距的水平直线。通常的例子是世界地图，如下图的这种影射类型
![a](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/atlas1.jpg)


# 什么是立方体贴片

立方体贴片正如其名所描述的－代表了一个立方体六个面的一系列图片等集合。真实世界被投射到立方体表面的，方式和全景图一样，唯一不同的是用立方体代替了球体模型。这种方式被大量应用于制作游戏里所需要的天空盒子。上面图例作为输入可以产生如下图：

![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/atlas1_CUBE.png)


## 1、全景图影射

从立方体贴图制作全景图最好的方式是先从全景图开始。其步骤如下：

* 1、对于全景图而言，我门要计算出来在对应的球体坐标系的坐标（记住，全景图是球体坐标的一个扁平影射）

* 2、接下来，想象一下用这个立方体包围起来球体（每个面和球上一个点相切)
*  3、假设立方体长度为1，中心坐标（0，0，0），球体中心也是（0，0，0）半径为1
*  4、为得到球体上坐标点像素，我门简单点从球体中心做一条射线，计算他在两个坐标系的相交点
*  这种办法我门可以得到立方体的每个点点像素值，同时设置到输出点全景上
*  重复这个过程直到我门遍历了全景图上所有的像素点


备注：这个过程使用了 Wolfram Alpha's的坐标模型


### 球体坐标系

首先我们要计算输出图像上每一点像素在球体上对应的坐标。如果全景图上的坐标是x，y，图片宽高分别为w，h，那么归一化的坐标向量(u,v)，其范围0-1，如果下所示 

```
u = x / w
v = y / h
```


球体坐标 θ 和 φ可以从归一化向量（u,v）计算出出来；θ描述的是从x＋坐标开始在xy平面上的旋转角度，范围取值为0 ≤ θ ≤ 2π；φ表示从极点出发和z轴的夹角，范围取值为0 ≤ φ ≤ π
```
θ = u*2π
φ = v*π
```
![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/polarcoords1.png)

### 笛卡尔坐标

我门可以使用3d极坐标计变换成一个单位向量，来计算出我门面向立方体的那个面。注意这里我们用的是单位向量，所以r半径不存在了，我门可以用如下公式计算出x，y，z的坐标

```

x = cosθsinφ
y = sinθsinφ
z = cosφ

```

接下来找到绝对值的最大值；然后根据这个值划分这些坐标；这些意味着xx，yy，zz可能为正也可能为负。无论那个值是最大的，这个标志暗示了是正面还是反面。因此，如，xx 等于＋1，表明设想方向朝x轴的正轴


```
maximum = max(abs(X),abs(Y),abs(Z))
xx = x / maximum
yy = y / maximum
zz = z / maximum

```

如下图所示证明

![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/3DFace.png)

上图所示我们可以计算出来xx = 0.713, yy = -0.232 and zz = 0.661,最大绝对值是.713，所以落在x轴上，并且我们知道射线朝向是x轴正方向

> 备注：
 其实，可以从另外一个维度计算θ 和 φ，θ比较简单，x＋正向时，范围取值为7π/4~1π/4,即315～45度；
 φ计算为 Math.asin(Math.sqrt(2,.5)/Math.sqrt(3,.5)) * 180/Math.PI=54.73561031724535
所以当0～54.73561031724535，属于z＋
当54.73561031724535～54.73561031724535 ＋ （180-54.73561031724535＊2）＝120.5287793655093,属于x＋，
 当120.5287793655093－180属于z－

### 3d投影

知道这一点，我们知道射线会和立方体的那一个面相交。这些信息使我们知道球体中心和立方体相交的点

```
if(xx==1 or xx==-1):
    projectX(theta,phi,xx)
else if (yy==1 or yy==-1):
    projectY(theta,phi,yy)
else:
    projectZ(theta,phi,zz)
```

因此，我们知道立方体那一面朝向哪里。这个信息可以帮助我们计算射线和立方体表面相交的坐标。例如我们选择x＋这个面，我们知道射线和面相交的坐标至少是立方体表面贴图长度的一半。因此在代码里我假设中心坐标时（0，0，0），因此x坐标是.5


```
def projectX(theta,phi,sign):

    x = sign*0.5
    rho = x/(cos(theta)*sin(phi))
    y = rho*sin(theta)*sin(phi)
    z = rho*cos(phi)
    return (x,y,z)
    
```

证明如下
![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/3DCartesian.jpeg)

### 2d 贴图像素

我门已经有要抽取的贴图上像素的坐标，现在3d的坐标位于立方体表面的某处，有三个维度。我们知道这个立方体可以分解为如下几个面

![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/unfolded_cube.png)

我门知道立方体被分解成以下几个面有如下几个原因：

* 1、 我门知道θ代表了xy平面，从x＋轴开始旋转0-2π范围。这意味着x＋对应的面对应的角度是从小于.25π且大于1.75π（φ的计算上文有提过)
* 对全景图而言，我们不断增加θ范围，按照逆时针方向依次会经过x＋，y＋，x－，y－
* φ = 0时指向z轴正方向，因此当φ = π时指向z轴负方向


我门需要转换3d坐标系为2d的坐标系，你通过观察上面和下面图示，发现这并不是一个简单的过程

![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/2DConvert.png)

依赖于你所处那个面，如上图所示轴的方向已经交换。在y＋面上，x＋指向右边，而y－方向指向左边。所以我门要改变每个面的坐标从左下xy（0，0）变动到左上（0，1）（原文我觉得有误，原文时（1，1）），正如你看到的，没个面的变换都不相同

两种坐标系的变换处理也比较简单，如下所示

```
def unit3DToUnit2D(x,y,z,faceIndex):

    if(faceIndex=="X+"):
        x2D = y+0.5
        y2D = z+0.5
    elif(faceIndex=="Y+"):
        x2D = (x*-1)+0.5
        y2D = z+0.5
    elif(faceIndex=="X-"):
        x2D = (y*-1)+0.5
        y2D = z+0.5
    elif(faceIndex=="Y-"):
        x2D = x+0.5
        y2D = z+0.5
    elif(faceIndex=="Z+"):
        x2D = y+0.5
        y2D = (x*-1)+0.5
    else:
        x2D = y+0.5
        y2D = x+0.5

    y2D = 1-y2D

```

注意最后改变了y轴方向，主要我用python脚本，对于图片来说y轴方向是方的，左上角是（0，0）

通过这个过程我门知道我门要寻找立方体那一面，并且也知道面上每个像素的位置。还有最后一步工作计算出来每一个面在输入图中的位置。这个过程比较简单，但是依赖你输入什么样的图片以及他们的布局。


![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/possible_cube_maps.jpg)


我用了一个简单的函数调整坐标到立方体中正确的位置

```
def offset(x,y,face):

    if(face=="X+"):
        ox = 1
        oy = 0
    elif(face=="X-"):
        ox = 3
        oy = 0
    elif(face=="Y+"):
        ox = 2
        oy = 0
    elif(face=="Y-"):
        ox = 0
        oy = 0
    elif(face=="Z+"):
        ox = 5
        oy = 0
    elif(face=="Z-"):
        ox = 4
        oy = 0

    ox *= squareLength
    oy *= squareLength

    return {"x":x+ox,"y":y+oy}
```



证明结束


### 结论

输入的图片按条状排列，在我的VR app输出如下图所示：

![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/fortPoint_Strip.png)

![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/fortPoint_Equi.png)

![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/fortPoint.gif)

## 2、生成立方体贴图

和生成全景图一样，再开始的时候我们对立方体贴图的概念在脑子里。基本步骤如下：


*  1）对于贴图中每一个像素，计算与其对应的面，如何做取决于你。同时要考虑立方体贴图的各种格式，包括条带，十字块或者六个单独的图像，我这里使用单独的六个图，稍后我会做解释
*  2）得到每一张图的像素坐标，并非整个贴图的
*  3）归一化这些坐标，使得范围在－0.5～0.5之间
*  4）根据你当前的立方体贴面填充完整的坐标，使得返回一个完整的3d矢量坐标
*  5）使用3d坐标转换成球体坐标
*  6）归一化球体坐标使得θ and φ 在 0 ～ 1之间
*  7）使用归一化坐标找到相应的全景提上对应的坐标
*  8）重复这个过程直到遍历完所有贴图上的像素


### 立方体贴图布局

如上面提到的立方体贴图有以下几种方式，如下图所示；这些方式并非所有的方式；我使用的是下图红色框中所展示的，你可以使用任何一种方式。一旦你确定使用那种图片格式，你要做的就是循环输出图像中的每一个像素。我门从最左上角的像素开始，逐渐往下遍历

![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/possible_cube_maps_red.jpg)





### 3d 笛卡尔坐标系

我开始遍历输出图像的所有像素。开始我需要知道遍历像素处于那个贴图。这并不是特别困难的事情，例如这个像素位于图片左边第三个同时处顶部的一半，很明显处于y－方向上。这种方式取决于你使用的贴图的布局


![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/3DCart_pt1.jpg)

一旦你知道了你所在贴图的那个面，你需要讲输出图像中的像素转换为立方体贴图面的局部坐标。例如在下图中，我们输出像素 的坐标（8，10），他位于z－坐标系内，调整此面的局部左边，变为（2，2）

![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/3DCart_pt2.jpg)

如果你得到每个面上的相对坐标，你需要将其归一化。对于球体和立方体来说，很显然中心坐标事（0，0，0），接下来我们就做这个。归一化立方体贴贴图坐标系使得其范围在-0.5~0.5之间。归一化并不是一个很直观的过程，因为我门使用的是一个立方体，在某些面上需要进行变换，如果在x＋面上，y＋指向右，在x－面上，y＋指向左边，你可以看到如下证明


上面的例子中我门使用的z－面，有一个相对坐标（2，2），通过使用每一个面大小来归一化这个坐标，每一个坐标宽高都为6，可以得到（0.33，0.33），当前范围是0-1，我门坐标范围变换到－0.5～0.5，减去0.5得到（-16，.16）

最后如果需要的话我门需要重新整理下坐标轴，你可以看到在z－面上，水平方向是y轴，竖直方向是x轴，由于当前在z－面上，所以z最小值为-0.5，根据这些信息，我门得到3d笛卡尔坐标系(-.16,.-.16,-.5)




![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/3DCart_pt3.jpg)



### 球体坐标

转换球体坐标是非常容易的事，我门仅仅使用如下公式


```
R = sqrt(X*X + Y*Y + Z*Z)

θ = atan2(Y/X)
φ = acos(Z/R)

Where θ is given in 2π radians and
φ is given in π radians
```


> 备注：
> 
> θ = ATan(y / x)求出的θ取值范围是[-PI/2, PI/2]。

> θ = ATan2(y, x)求出的θ取值范围是[-PI, PI]。

我门可以用之前给的坐标xyz(-.16,.-.16,-.5)来计算笛卡尔坐标


```
R = sqrt(X*X + Y*Y + Z*Z) = 0.5488
θ = atan2(Y/X) = -2.3562
φ = acos(Z/R) = 2.7167
```

### 2D 笛卡尔坐标

开始最后一步，我门要转化球体左边为可以直接在输入图片上使用的坐标。首先归一化球体坐标，我们知道θ 范围 0-2π, π 范围0-π ，所以我门分割把θ 进行2 π等分后给u， π 给 V:


```
U = θ/2π = -0.375 or 0.625
V = φ/π = 0.8
```
给定的全景图上查找距左边62.5%，距上边86.5%位置的像素，如下图绿点所示

![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/selected_equirect_pixel.jpg)

遍历给定的所有贴图的像素，可以得到下图

![](https://raw.githubusercontent.com/ddtf/blog/master/2018-09/vr/atlas1_CUBE.png)


### 更多

使用的素材包括立方体贴图，参见[Humus.name](http://www.humus.name/index.php?page=Textures)


全景图影射，可以参考 [Wikipedia](https://en.wikipedia.org/wiki/Equirectangular_projection)和[Wolfram Mathworld](http://mathworld.wolfram.com/EquirectangularProjection.html)

联系我可以到[LinkedIn](https://www.linkedin.com/in/paul-reed-19a7a884), [Twitter](https://twitter.com/paulrreed), or [YouTube](https://www.youtube.com/channel/UCbV7nV-K1AIi8Z70F29zsvw)

转换成全景图的脚本使用的是python，我的VR 应用使用的是 Objective-C

你可以下载使用我的代码[GitHub](https://github.com/PaulReedMakes)



> 感谢[MJingv](https://github.com/MJingv)校对
















